<script lang="ts">
import { type Chat } from '@ai-sdk/svelte';
import type { Attachment } from '@ai-sdk/ui-utils';
import { onMount } from 'svelte';
import { innerWidth } from 'svelte/reactivity/window';
import { toast } from 'svelte-sonner';

import { LocalStorage } from '/@/lib/chat/hooks/local-storage.svelte';
import { cn } from '/@/lib/chat/utils/shadcn';

import ArrowUpIcon from './icons/arrow-up.svelte';
import PaperclipIcon from './icons/paperclip.svelte';
import StopIcon from './icons/stop.svelte';
import PreviewAttachment from './preview-attachment.svelte';
import SuggestedActions from './suggested-actions.svelte';
import { Button } from './ui/button';
import { Textarea } from './ui/textarea';

let {
  attachments = $bindable(),
  chatClient,
  class: c,
}: {
  attachments: Attachment[];
  chatClient: Chat;
  class?: string;
} = $props();

let input = $state('');
let mounted = $state(false);
let textareaRef = $state<HTMLTextAreaElement | null>(null);
let fileInputRef = $state<HTMLInputElement | null>(null);
let uploadQueue = $state<string[]>([]);
const storedInput = new LocalStorage('input', '');
const loading = $derived(chatClient.status === 'streaming' || chatClient.status === 'submitted');

const adjustHeight = (): void => {
  if (textareaRef) {
    textareaRef.style.height = 'auto';
    textareaRef.style.height = `${textareaRef.scrollHeight + 2}px`;
  }
};

const resetHeight = (): void => {
  if (textareaRef) {
    textareaRef.style.height = 'auto';
    textareaRef.style.height = '98px';
  }
};

function setInput(value: string): void {
  input = value;
  adjustHeight();
}

async function submitForm(): Promise<void> {
  const text = input;
  setInput('');
  await chatClient.sendMessage({
    text,
    files: attachments.map(attachment => ({
      type: 'file',
      url: attachment.url,
      name: attachment.name,
      mediaType: attachment.contentType!,
    })),
  });

  attachments = [];
  resetHeight();

  if (innerWidth.current && innerWidth.current > 768) {
    textareaRef?.focus();
  }
}

async function uploadFile(file: File): Promise<
  | {
      url: string;
      name: string;
      contentType: string;
    }
  | undefined
> {
  const formData = new FormData();
  formData.append('file', file);

  try {
    const response = await fetch('/api/files/upload', {
      method: 'POST',
      body: formData,
    });

    if (response.ok) {
      const data = await response.json();
      const { url, pathname, contentType } = data;

      return {
        url,
        name: pathname,
        contentType: contentType,
      };
    }
    const { message } = await response.json();
    toast.error(message);
  } catch {
    toast.error('Failed to upload file, please try again!');
  }
}

async function handleFileChange(
  event: Event & {
    currentTarget: EventTarget & HTMLInputElement;
  },
): Promise<void> {
  const files = Array.from(event.currentTarget.files ?? []);
  uploadQueue = files.map(file => file.name);

  try {
    const uploadPromises = files.map(file => uploadFile(file));
    const uploadedAttachments = await Promise.all(uploadPromises);
    const successfullyUploadedAttachments = uploadedAttachments.filter(attachment => attachment !== undefined);

    attachments = [...attachments, ...successfullyUploadedAttachments];
  } catch (error) {
    console.error('Error uploading files!', error);
  } finally {
    uploadQueue = [];
  }
}

onMount(() => {
  input = storedInput.value;
  adjustHeight();
  mounted = true;
});

$effect.pre(() => {
  storedInput.value = input;
});
</script>

<div class="relative flex w-full flex-col gap-4">
	{#if mounted && chatClient.messages.length === 0 && attachments.length === 0 && uploadQueue.length === 0}
		<SuggestedActions {chatClient} />
	{/if}

	<input
		type="file"
		class="pointer-events-none fixed -top-4 -left-4 size-0.5 opacity-0"
		bind:this={fileInputRef}
		multiple
		onchange={handleFileChange}
		tabIndex={-1}
	/>

	{#if attachments.length > 0 || uploadQueue.length > 0}
		<div class="flex flex-row items-end gap-2 overflow-x-scroll">
			{#each attachments as attachment (attachment.url)}
				<PreviewAttachment {attachment} />
			{/each}

			{#each uploadQueue as filename (filename)}
				<PreviewAttachment
					attachment={{
						url: '',
						name: filename,
						contentType: '',
					}}
					uploading
				/>
			{/each}
		</div>
	{/if}

	<Textarea
		bind:ref={textareaRef}
		placeholder="Send a message..."
		bind:value={():string => input, setInput}
		class={cn(
			'bg-muted max-h-[calc(75dvh)] min-h-[24px] resize-none overflow-hidden rounded-2xl pb-10 !text-base dark:border-zinc-700',
			c
		)}
		rows={2}
		autofocus
		onkeydown={async(event): Promise<void> => {
			if (event.key === 'Enter' && !event.shiftKey && !event.isComposing) {
				event.preventDefault();

				if (loading) {
					toast.error('Please wait for the model to finish its response!');
				} else {
					await submitForm();
				}
			}
		}}
	/>

	<div class="absolute bottom-0 flex w-fit flex-row justify-start p-2">
		<Button
			class="h-fit rounded-md rounded-bl-lg p-[7px] hover:bg-zinc-200 dark:border-zinc-700 hover:dark:bg-zinc-900"
			onclick={(event): void => {
				event.preventDefault();
				fileInputRef?.click();
			}}
			disabled={loading}
			variant="ghost"
		>
			<PaperclipIcon size={14} />
		</Button>
	</div>

	<div class="absolute right-0 bottom-0 flex w-fit flex-row justify-end p-2">
		{#if loading}
			<Button
				class="h-fit rounded-full border p-1.5 dark:border-zinc-600"
				onclick={(event): void => {
					event.preventDefault();
					stop();
					chatClient.messages = chatClient.messages;
				}}
			>
				<StopIcon size={14} />
			</Button>
		{:else}
			<Button
					class="h-fit rounded-full border p-1.5 dark:border-zinc-600"
					onclick={async(event): Promise<void> => {
						event.preventDefault();
						await submitForm();
					}}
					disabled={input.length === 0 || uploadQueue.length > 0}
				>
				<ArrowUpIcon size={14} />
			</Button>
		{/if}
	</div>
</div>


